Mecanismos de Sincronzação comparados

Semáforos vs synchronized

Característica -Semáforos (java.util.concurrent),     Monitores (synchronized / wait-notify)
Abstração-      Alto Nível (API pronta),              Baixo Nível (Primitivas da linguagem)
Complexidade-   Baixa (acquire()/release())           Média/Alta (Exige lógica manual)
Fairness (Justiça)- "Automático (new Semaphore(1, true))"      Manual (Implementação de Ticket Lock)
Performance-    Ligeiro Overhead da API,              Otimizado pela JVM (Intrinsic Locks)
Uso no Projeto- Cenários Padrão,                      Cenários de Comparação e Controle Fino

Destaque técnico
Explica que para resolver o Starvation com wait/notify,
tiveste de implementar um algoritmo de "Senhas" (Ticket Lock) manualmente,
provando que dominas a lógica de exclusão mútua e não apenas o uso de bibliotecas prontas.



Análise de escalabilidade

-Objetivo: Validar a robustez do sistema sob carga elevada (Cenário 4).

Metodologia: "Foram lançadas N threads (ex: 1000) simultâneas para simular um pico de tráfego (Black Friday Bancária)."

O desafio da I/O - explicar que foi necessária a criação do SilentMode
Para testar a performance real das threads, o output foi suprimido, mantendo apenas a gravação em disco assíncrona/bufferizada."

Resultados: Apresenta os dados que o RunStressTest cospe no final:

-Throughput: X Transações/segundo.
-Integridade: Saldo Final Esperado vs Real (Sucesso/Falha).



Segurança e Resiliência(IPS)º
-Em alguns casos como deadlock inseguro, na consola dá um erro fatal, que é gerado
automaticamente pelo sistema para simular um crash do deadlock


Novas alterações
-Foi criado novos métodos para synchronized
-Foi criado uma nova classe para funcionar com o starvationSybchronized

